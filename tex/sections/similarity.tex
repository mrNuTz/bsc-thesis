\documentclass[../main.tex]{subfiles}
\begin{document}

The following methods where used to obtain similarity scores, applied to digests and undigested codes.

\subsection{Jaccard-Index \label{sec:jacc}}

Defined on two sets \(A, B\), the Jaccard Index \(J\) is the ratio of common entries to all entries.
\begin{equation}
  J(A,B) = |A \cap B| / |A \cup B| \in [0,1]
  \label{eq:jaccard}
\end{equation}

\subsection{Levenshtein Distance \label{sec:lev}}

Also called edit distance is the minimum number of character-inserts, -deletions and -substitutions necessary to change one string into the other.

The be consistent with the other measures I calculated the Levenshtein similarity as follows:
\begin{equation}
  similarity(a, b) = 1 - distance(a, b) / max\{|a|, |b|\} \in [0,1]
  \label{eq:levSim}
\end{equation}

Levenshtein edit distance on the whole code. Only used with very small codes (e.g. \n{proxies}).
The \n{pyPI} package \n{python-Levenshtein} was used \cite{pyLev}.

\subsection{Normalized compression distance NCD \label{sec:ncd}}

NCD is a measure for how well two files co-compress---the more features two files have in common the shorter the length of the compressed concatenation.

$Z(x)$ is the length of the compressed file $x$ ; $xy$ is the concatenation of $x$ and $y$.

\begin{equation}
  NCD(x,y) = \dfrac{Z(xy) - \min \{Z(x),Z(y)\}}{\max \{Z(x),Z(y)\}}
\end{equation}

I calculation the similarity instead of the distance to be consistent with the other measures.

\begin{lstlisting}[style=pymd]
import lzma

def Z(contents: bytes) -> int:
  return len(lzma.compress(contents, format=lzma.FORMAT_RAW))

# Simplified Python code: Z(a) is calculated of all codes a before comparing
def NCD(a: bytes, b: bytes):
  return (Z(a + b) - min(Z(a), Z(b))) / max(Z(a), Z(b))

def similarity(a: bytes, b: bytes):
  return (Z(a) + Z(b) - Z(a + b)) / max(Z(a), Z(b))
\end{lstlisting}

\subsection{Code Length \label{sec:size}}

To test if the other methods are just an expensive proxy for a length comparison, I obtained a similarity score purely based on the size of the codes.

\begin{equation}
  sim(a, b) = \dfrac{\min\{|a|,|b|\}}{\max\{|a|,|b|\}} \in [0,1]
  \label{eq:size}
\end{equation}

\end{document}
